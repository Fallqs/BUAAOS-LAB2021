!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BY2PIPE	pipe.c	20;"	d	file:
Ctod	print.c	16;"	d	file:
Dev	fd.h	/^struct Dev {$/;"	s
FDTABLE	fd.h	11;"	d
FILEBASE	fd.h	10;"	d
Fd	fd.h	/^struct Fd {$/;"	s
Filefd	fd.h	/^struct Filefd {$/;"	s
INCLUDES	Makefile	/^INCLUDES = -I..\/include\/$/;"	m
INDEX2DATA	fd.h	14;"	d
INDEX2FD	fd.h	13;"	d
IsDigit	print.c	15;"	d	file:
LIB_H	lib.h	2;"	d
MAXFD	fd.h	9;"	d
OUTPUT	print.c	36;"	d	file:
O_ACCMODE	lib.h	139;"	d
O_CREAT	lib.h	141;"	d
O_EXCL	lib.h	143;"	d
O_MKDIR	lib.h	144;"	d
O_RDONLY	lib.h	136;"	d
O_RDWR	lib.h	138;"	d
O_TRUNC	lib.h	142;"	d
O_WRONLY	lib.h	137;"	d
Pipe	pipe.c	/^struct Pipe {$/;"	s	file:
Stat	fd.h	/^struct Stat {$/;"	s
USED	lib.h	18;"	d
USERLIB	Makefile	/^USERLIB := printf.o \\$/;"	m
_USER_FD_H_	fd.h	2;"	d
__asm_pgfault_handler	entry.S	/^__asm_pgfault_handler:$/;"	l
__pgfault_handler	entry.S	/^	__pgfault_handler:$/;"	l
_pipeisclosed	pipe.c	/^_pipeisclosed(struct Fd *fd, struct Pipe *p)$/;"	f	file:
_start	entry.S	/^_start:$/;"	l
_user_panic	printf.c	/^_user_panic(const char *file, int line, const char *fmt, ...)$/;"	f
close	fd.c	/^close(int fdnum)$/;"	f
close_all	fd.c	/^close_all(void)$/;"	f
cons_close	console.c	/^cons_close(struct Fd *fd)$/;"	f
cons_read	console.c	/^cons_read(struct Fd *fd, void *vbuf, u_int n, u_int offset)$/;"	f
cons_stat	console.c	/^cons_stat(struct Fd *fd, struct Stat *stat)$/;"	f
cons_write	console.c	/^cons_write(struct Fd *fd, const void *vbuf, u_int n, u_int offset)$/;"	f
debug	fd.h	7;"	d
debug	file.c	4;"	d	file:
debug	fsipc.c	5;"	d	file:
debug	pipe.c	4;"	d	file:
dev_close	fd.h	/^	int (*dev_close)(struct Fd *);$/;"	m	struct:Dev
dev_id	fd.h	/^	int dev_id;$/;"	m	struct:Dev
dev_lookup	fd.c	/^dev_lookup(int dev_id, struct Dev **dev)$/;"	f
dev_name	fd.h	/^	char *dev_name;$/;"	m	struct:Dev
dev_read	fd.h	/^	int (*dev_read)(struct Fd *, void *, u_int, u_int);$/;"	m	struct:Dev
dev_seek	fd.h	/^	int (*dev_seek)(struct Fd *, u_int);$/;"	m	struct:Dev
dev_stat	fd.h	/^	int (*dev_stat)(struct Fd *, struct Stat *);$/;"	m	struct:Dev
dev_write	fd.h	/^	int (*dev_write)(struct Fd *, const void *, u_int, u_int);$/;"	m	struct:Dev
devcons	console.c	/^struct Dev devcons = {$/;"	v	typeref:struct:Dev
devfile	file.c	/^struct Dev devfile = {$/;"	v	typeref:struct:Dev
devpipe	pipe.c	/^struct Dev devpipe = {$/;"	v	typeref:struct:Dev
devtab	fd.c	/^static struct Dev *devtab[] = {$/;"	v	typeref:struct:Dev	file:
diff_msg	fstest.c	/^static char *diff_msg = "This is a different massage of the day!\\r\\n\\r\\n";$/;"	v	file:
dup	fd.c	/^dup(int oldfdnum, int newfdnum)$/;"	f
duppage	fork.c	/^duppage(u_int envid, u_int pn)$/;"	f	file:
env	libos.c	/^struct Env *env;$/;"	v	typeref:struct:Env
envs	entry.S	/^envs:$/;"	l
exit	libos.c	/^exit(void)$/;"	f
f_fd	fd.h	/^	struct Fd f_fd;$/;"	m	struct:Filefd	typeref:struct:Filefd::Fd
f_file	fd.h	/^	struct File f_file;$/;"	m	struct:Filefd	typeref:struct:Filefd::File
f_fileid	fd.h	/^	u_int f_fileid;$/;"	m	struct:Filefd
fd2data	fd.c	/^fd2data(struct Fd *fd)$/;"	f
fd2num	fd.c	/^fd2num(struct Fd *fd)$/;"	f
fd_alloc	fd.c	/^fd_alloc(struct Fd **fd)$/;"	f
fd_close	fd.c	/^fd_close(struct Fd *fd)$/;"	f
fd_dev_id	fd.h	/^	u_int fd_dev_id;$/;"	m	struct:Fd
fd_lookup	fd.c	/^fd_lookup(int fdnum, struct Fd **fd)$/;"	f
fd_offset	fd.h	/^	u_int fd_offset;$/;"	m	struct:Fd
fd_omode	fd.h	/^	u_int fd_omode;$/;"	m	struct:Fd
fdtab	entry.S	/^fdtab:$/;"	l
file_close	file.c	/^file_close(struct Fd *fd)$/;"	f
file_read	file.c	/^file_read(struct Fd *fd, void *buf, u_int n, u_int offset)$/;"	f	file:
file_stat	file.c	/^file_stat(struct Fd *fd, struct Stat *st)$/;"	f	file:
file_write	file.c	/^file_write(struct Fd *fd, const void *buf, u_int n, u_int offset)$/;"	f	file:
fork	fork.c	/^fork(void)$/;"	f
fsipc	fsipc.c	/^fsipc(u_int type, void *fsreq, u_int dstva, u_int *perm)$/;"	f	file:
fsipc_close	fsipc.c	/^fsipc_close(u_int fileid)$/;"	f
fsipc_dirty	fsipc.c	/^fsipc_dirty(u_int fileid, u_int offset)$/;"	f
fsipc_map	fsipc.c	/^fsipc_map(u_int fileid, u_int offset, u_int dstva)$/;"	f
fsipc_open	fsipc.c	/^fsipc_open(const char *path, u_int omode, struct Fd *fd)$/;"	f
fsipc_remove	fsipc.c	/^fsipc_remove(const char *path)$/;"	f
fsipc_set_size	fsipc.c	/^fsipc_set_size(u_int fileid, u_int size)$/;"	f
fsipc_sync	fsipc.c	/^fsipc_sync(void)$/;"	f
fsipcbuf	entry.S	/^fsipcbuf:$/;"	l
fstat	fd.c	/^int fstat(int fdnum, struct Stat *stat)$/;"	f
ftruncate	file.c	/^ftruncate(int fdnum, u_int size)$/;"	f
fwritef	fprintf.c	/^int fwritef(int fd, const char *fmt, ...)$/;"	f
ipc_recv	ipc.c	/^ipc_recv(u_int *whom, u_int dstva, u_int *perm)$/;"	f
ipc_send	ipc.c	/^ipc_send(u_int whom, u_int val, u_int srcva, u_int perm)$/;"	f
iscons	console.c	/^iscons(int fdnum)$/;"	f
libmain	libos.c	/^libmain(int argc, char **argv)$/;"	f
memcpy	string.c	/^memcpy(void *destaddr, void const *srcaddr, u_int len)$/;"	f
msg	fstest.c	/^static char *msg = "This is the NEW message of the day!\\r\\n\\r\\n";$/;"	v	file:
nop	entry.S	/^nop$/;"	l
num2fd	fd.c	/^num2fd(int fd)$/;"	f
open	file.c	/^open(const char *path, int mode)$/;"	f
opencons	console.c	/^opencons(void)$/;"	f
p_buf	pipe.c	/^	u_char p_buf[BY2PIPE];	\/\/ data buffer$/;"	m	struct:Pipe	file:
p_rpos	pipe.c	/^	u_int p_rpos;		    \/\/ read position$/;"	m	struct:Pipe	file:
p_wpos	pipe.c	/^	u_int p_wpos;		    \/\/ write position$/;"	m	struct:Pipe	file:
pageref	pageref.c	/^pageref(void *v)$/;"	f
pages	entry.S	/^pages:$/;"	l
pgfault	fork.c	/^pgfault(u_int va)$/;"	f	file:
pipe	pipe.c	/^pipe(int pfd[2])$/;"	f
pipeclose	pipe.c	/^pipeclose(struct Fd *fd)$/;"	f	file:
pipeisclosed	pipe.c	/^pipeisclosed(int fdnum)$/;"	f
piperead	pipe.c	/^piperead(struct Fd *fd, void *vbuf, u_int n, u_int offset)$/;"	f	file:
pipestat	pipe.c	/^pipestat(struct Fd *fd, struct Stat *stat)$/;"	f	file:
pipewrite	pipe.c	/^pipewrite(struct Fd *fd, const void *vbuf, u_int n, u_int offset)$/;"	f	file:
read	fd.c	/^read(int fdnum, void *buf, u_int n)$/;"	f
read_map	file.c	/^read_map(int fdnum, u_int offset, void **blk)$/;"	f
readn	fd.c	/^readn(int fdnum, void *buf, u_int n)$/;"	f
remove	file.c	/^remove(const char *path)$/;"	f
seek	fd.c	/^seek(int fdnum, u_int offset)$/;"	f
set_pgfault_handler	pgfault.c	/^set_pgfault_handler(void (*fn)(u_int va))$/;"	f
sfork	fork.c	/^sfork(void)$/;"	f
st_dev	fd.h	/^	struct Dev *st_dev;$/;"	m	struct:Stat	typeref:struct:Stat::Dev
st_isdir	fd.h	/^	u_int st_isdir;$/;"	m	struct:Stat
st_name	fd.h	/^	char st_name[MAXNAMELEN];$/;"	m	struct:Stat
st_size	fd.h	/^	u_int st_size;$/;"	m	struct:Stat
stat	fd.c	/^stat(const char *path, struct Stat *stat)$/;"	f
strchr	string.c	/^strchr(const char *s, char c)$/;"	f
strcmp	string.c	/^strcmp(const char *p, const char *q)$/;"	f
strcpy	string.c	/^strcpy(char *dst, const char *src)$/;"	f
strlen	string.c	/^strlen(const char *s)$/;"	f
sync	file.c	/^sync(void)$/;"	f
syscall_cgetc	syscall_lib.c	/^syscall_cgetc()$/;"	f
syscall_env_alloc	lib.h	/^inline static int syscall_env_alloc(void)$/;"	f
syscall_env_destroy	syscall_lib.c	/^syscall_env_destroy(u_int envid)$/;"	f
syscall_getenvid	syscall_lib.c	/^syscall_getenvid(void)$/;"	f
syscall_ipc_can_send	syscall_lib.c	/^syscall_ipc_can_send(u_int envid, u_int value, u_int srcva, u_int perm)$/;"	f
syscall_ipc_recv	syscall_lib.c	/^syscall_ipc_recv(u_int dstva)$/;"	f
syscall_mem_alloc	syscall_lib.c	/^syscall_mem_alloc(u_int envid, u_int va, u_int perm)$/;"	f
syscall_mem_map	syscall_lib.c	/^syscall_mem_map(u_int srcid, u_int srcva, u_int dstid, u_int dstva, u_int perm)$/;"	f
syscall_mem_unmap	syscall_lib.c	/^syscall_mem_unmap(u_int envid, u_int va)$/;"	f
syscall_panic	syscall_lib.c	/^syscall_panic(char *msg)$/;"	f
syscall_putchar	syscall_lib.c	/^void syscall_putchar(char ch)$/;"	f
syscall_read_dev	syscall_lib.c	/^syscall_read_dev(u_int va, u_int dev, u_int len)$/;"	f
syscall_set_env_status	syscall_lib.c	/^syscall_set_env_status(u_int envid, u_int status)$/;"	f
syscall_set_pgfault_handler	syscall_lib.c	/^syscall_set_pgfault_handler(u_int envid, void (*func)(void), u_int xstacktop)$/;"	f
syscall_set_trapframe	syscall_lib.c	/^syscall_set_trapframe(u_int envid, struct Trapframe *tf)$/;"	f
syscall_write_dev	syscall_lib.c	/^syscall_write_dev(u_int va, u_int dev, u_int len)$/;"	f
syscall_yield	syscall_lib.c	/^syscall_yield(void)$/;"	f
umain	fktest.c	/^void umain()$/;"	f
umain	fstest.c	/^void umain()$/;"	f
umain	idle.c	/^void umain()$/;"	f
umain	pingpong.c	/^umain(void)$/;"	f
user_PrintChar	print.c	/^user_PrintChar(char *buf, char c, int length, int ladjust)$/;"	f
user_PrintNum	print.c	/^user_PrintNum(char *buf, unsigned long u, int base, int negFlag,$/;"	f
user_PrintString	print.c	/^user_PrintString(char *buf, char *s, int length, int ladjust)$/;"	f
user_assert	lib.h	132;"	d
user_bcopy	fork.c	/^void user_bcopy(const void *src, void *dst, size_t len)$/;"	f
user_bzero	fork.c	/^void user_bzero(void *v, u_int n)$/;"	f
user_lp_Print	print.c	/^user_lp_Print(void (*output)(void *, const char *, int),$/;"	f
user_myoutput	printf.c	/^static void user_myoutput(void *arg, const char *s, int l)$/;"	f	file:
user_out2string	fprintf.c	/^static void user_out2string(void *arg, const char *s, int l)$/;"	f	file:
user_panic	lib.h	33;"	d
user_theFatalMsg	print.c	/^static const char user_theFatalMsg[] = "fatal error in user_lp_Print!";$/;"	v	file:
vpd	entry.S	/^vpd:$/;"	l
vpt	entry.S	/^vpt:$/;"	l
write	fd.c	/^write(int fdnum, const void *buf, u_int n)$/;"	f
writef	printf.c	/^void writef(char *fmt, ...)$/;"	f
