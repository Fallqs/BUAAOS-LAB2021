!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BY2PIPE	pipe.c	21;"	d	file:
Ctod	print.c	16;"	d	file:
Dev	fd.h	/^struct Dev$/;"	s
FDTABLE	fd.h	59;"	d
FILEBASE	fd.h	58;"	d
Fd	fd.h	/^struct Fd$/;"	s
Filefd	fd.h	/^struct Filefd $/;"	s
INCLUDES	Makefile	/^INCLUDES = -I..\/include\/$/;"	m
INDEX2DATA	fd.h	62;"	d
INDEX2FD	fd.h	61;"	d
IsDigit	print.c	15;"	d	file:
LIB_H	lib.h	2;"	d
MAXARGS	sh.c	79;"	d	file:
MAXFD	fd.h	57;"	d
MY_MUL	init.c	/^inline int MY_MUL(int a,int b)$/;"	f
OUTPUT	print.c	36;"	d	file:
O_ACCMODE	lib.h	137;"	d
O_CREAT	lib.h	139;"	d
O_EXCL	lib.h	141;"	d
O_MKDIR	lib.h	142;"	d
O_RDONLY	lib.h	134;"	d
O_RDWR	lib.h	136;"	d
O_TRUNC	lib.h	140;"	d
O_WRONLY	lib.h	135;"	d
Pipe	pipe.c	/^struct Pipe {$/;"	s	file:
SYMBOLS	sh.c	19;"	d	file:
Stat	fd.h	/^struct Stat$/;"	s
TMPPAGE	spawn.c	7;"	d	file:
TMPPAGETOP	spawn.c	8;"	d	file:
TMPVA	testptelibrary.c	2;"	d	file:
USED	lib.h	18;"	d
USERLIB	Makefile	/^USERLIB := printf.o \\$/;"	m
WHITESPACE	sh.c	18;"	d	file:
_USER_FD_H_	fd.h	2;"	d
__asm_pgfault_handler	entry.S	/^	__asm_pgfault_handler:$/;"	l
__pgfault_handler	entry.S	/^	__pgfault_handler:$/;"	l
_gettoken	sh.c	/^_gettoken(char *s, char **p1, char **p2)$/;"	f
_pipeisclosed	pipe.c	/^_pipeisclosed(struct Fd *fd, struct Pipe *p)$/;"	f	file:
_start	entry.S	/^	_start:$/;"	l
_user_panic	printf.c	/^_user_panic(const char *file, int line, const char *fmt,...)$/;"	f
bol	num.c	/^int bol = 1;$/;"	v
bss	init.c	/^char bss[6000];$/;"	v
buf	cat.c	/^char buf[8192];$/;"	v
buf	sh.c	/^char buf[1024];$/;"	v
buf	testfdsharing.c	/^char buf[512], buf2[512];$/;"	v
buf2	testfdsharing.c	/^char buf[512], buf2[512];$/;"	v
cat	cat.c	/^cat(int f, char *s)$/;"	f
childofspawn	testptelibrary.c	/^void childofspawn(void){$/;"	f
close	fd.c	/^close(int fdnum)$/;"	f
close_all	fd.c	/^close_all(void)$/;"	f
cons_close	console.c	/^cons_close(struct Fd *fd)$/;"	f
cons_read	console.c	/^cons_read(struct Fd *fd, void *vbuf, u_int n, u_int offset)$/;"	f
cons_stat	console.c	/^cons_stat(struct Fd *fd, struct Stat *stat)$/;"	f
cons_write	console.c	/^cons_write(struct Fd *fd, const void *vbuf, u_int n, u_int offset)$/;"	f
data	init.c	/^} data = {$/;"	v	typeref:struct:__anon1
debug	fd.h	55;"	d
debug	file.c	4;"	d	file:
debug	fsipc.c	5;"	d	file:
debug	pipe.c	4;"	d	file:
debug	spawn.c	6;"	d	file:
debug_	sh.c	/^int debug_ = 0;$/;"	v
dev_close	fd.h	/^	int (*dev_close)(struct Fd*);$/;"	m	struct:Dev
dev_id	fd.h	/^	int dev_id;$/;"	m	struct:Dev
dev_lookup	fd.c	/^dev_lookup(int dev_id, struct Dev **dev)$/;"	f
dev_name	fd.h	/^	char *dev_name;$/;"	m	struct:Dev
dev_read	fd.h	/^	int (*dev_read)(struct Fd*, void*, u_int, u_int);$/;"	m	struct:Dev
dev_seek	fd.h	/^	int (*dev_seek)(struct Fd*, u_int);$/;"	m	struct:Dev
dev_stat	fd.h	/^	int (*dev_stat)(struct Fd*, struct Stat*);$/;"	m	struct:Dev
dev_write	fd.h	/^	int (*dev_write)(struct Fd*, const void*, u_int, u_int);$/;"	m	struct:Dev
devcons	console.c	/^struct Dev devcons =$/;"	v	typeref:struct:Dev
devfile	file.c	/^struct Dev devfile = {$/;"	v	typeref:struct:Dev
devpipe	pipe.c	/^struct Dev devpipe =$/;"	v	typeref:struct:Dev
devtab	fd.c	/^static struct Dev *devtab[] = {$/;"	v	typeref:struct:Dev	file:
diff_msg	fstest.c	/^static char *diff_msg = "This is a different massage of the day!\\r\\n\\r\\n";$/;"	v	file:
dup	fd.c	/^dup(int oldfdnum, int newfdnum)$/;"	f
duppage	fork.c	/^duppage(u_int envid, u_int pn)$/;"	f	file:
env	libos.c	/^struct Env *env;$/;"	v	typeref:struct:Env
envs	entry.S	/^envs:$/;"	l
exit	libos.c	/^exit(void)$/;"	f
f_fd	fd.h	/^	struct Fd f_fd;$/;"	m	struct:Filefd	typeref:struct:Filefd::Fd
f_file	fd.h	/^	struct File f_file;$/;"	m	struct:Filefd	typeref:struct:Filefd::File
f_fileid	fd.h	/^	u_int f_fileid;$/;"	m	struct:Filefd
fd2data	fd.c	/^fd2data(struct Fd *fd)$/;"	f
fd2num	fd.c	/^fd2num(struct Fd *fd)$/;"	f
fd_alloc	fd.c	/^fd_alloc(struct Fd **fd)$/;"	f
fd_close	fd.c	/^fd_close(struct Fd *fd)$/;"	f
fd_dev_id	fd.h	/^	u_int fd_dev_id;$/;"	m	struct:Fd
fd_lookup	fd.c	/^fd_lookup(int fdnum, struct Fd **fd)$/;"	f
fd_offset	fd.h	/^	u_int fd_offset;$/;"	m	struct:Fd
fd_omode	fd.h	/^	u_int fd_omode;$/;"	m	struct:Fd
fdtab	entry.S	/^fdtab:$/;"	l
file_close	file.c	/^file_close(struct Fd *fd)$/;"	f
file_read	file.c	/^file_read(struct Fd *fd, void *buf, u_int n, u_int offset)$/;"	f	file:
file_stat	file.c	/^file_stat(struct Fd *fd, struct Stat *st)$/;"	f	file:
file_write	file.c	/^file_write(struct Fd *fd, const void *buf, u_int n, u_int offset)$/;"	f	file:
flag	ls.c	/^int flag[256];$/;"	v
fork	fork.c	/^fork(void)$/;"	f
fsipc	fsipc.c	/^fsipc(u_int type, void *fsreq, u_int dstva, u_int *perm)$/;"	f	file:
fsipc_close	fsipc.c	/^fsipc_close(u_int fileid)$/;"	f
fsipc_dirty	fsipc.c	/^fsipc_dirty(u_int fileid, u_int offset)$/;"	f
fsipc_map	fsipc.c	/^fsipc_map(u_int fileid, u_int offset, u_int dstva)$/;"	f
fsipc_open	fsipc.c	/^fsipc_open(const char *path, u_int omode, struct Fd *fd)$/;"	f
fsipc_remove	fsipc.c	/^fsipc_remove(const char *path)$/;"	f
fsipc_set_size	fsipc.c	/^fsipc_set_size(u_int fileid, u_int size)$/;"	f
fsipc_sync	fsipc.c	/^fsipc_sync(void)$/;"	f
fsipcbuf	entry.S	/^fsipcbuf:$/;"	l
fstat	fd.c	/^int fstat(int fdnum, struct Stat *stat)$/;"	f
ftruncate	file.c	/^ftruncate(int fdnum, u_int size)$/;"	f
fwritef	fprintf.c	/^int fwritef(int fd, const char *fmt, ...)$/;"	f
gettoken	sh.c	/^gettoken(char *s, char **p1)$/;"	f
init_stack	spawn.c	/^init_stack(u_int child, char **argv, u_int *init_esp)$/;"	f
ipc_recv	ipc.c	/^ipc_recv(u_int *whom, u_int dstva, u_int *perm)$/;"	f
ipc_send	ipc.c	/^ipc_send(u_int whom, u_int val, u_int srcva, u_int perm)$/;"	f
iscons	console.c	/^iscons(int fdnum)$/;"	f
libmain	libos.c	/^libmain(int argc, char **argv)$/;"	f
line	num.c	/^int line = 0;$/;"	v
ls	ls.c	/^ls(char *path, char *prefix)$/;"	f
ls1	ls.c	/^ls1(char *prefix, u_int isdir, u_int size, char *name)$/;"	f
lsdir	ls.c	/^lsdir(char *path, char *prefix)$/;"	f
lw	entry.S	/^lw	a0, TF_BADVADDR(sp)$/;"	l
lw	entry.S	/^lw	a1, 4(sp)$/;"	l
lw	entry.S	/^lw	k0,TF_EPC(sp) 	\/\/atomic operation needed $/;"	l
lw	entry.S	/^lw	sp,TF_REG29(sp)  \/* Deallocate stack *\/  $/;"	l
lw	entry.S	/^lw	v1,TF_EPC(sp)                    $/;"	l
lw	entry.S	/^lw	v1,TF_LO(sp)                                       $/;"	l
memcmp	testfdsharing.c	/^memcmp(char *a, char *b, int n)$/;"	f
memcpy	string.c	/^memcpy(void *destaddr,void const *srcaddr,u_int len)$/;"	f
msg	fstest.c	/^static char *msg = "This is the NEW message of the day!\\r\\n\\r\\n";$/;"	v	file:
msg	testpipe.c	/^char *msg = "Now is the time for all good men to come to the aid of their party.";$/;"	v
msg	testptelibrary.c	/^const char *msg = "hello world!\\n";$/;"	v
msg1	init.c	/^	char msg1[5000];$/;"	m	struct:__anon1	file:
msg2	init.c	/^	char msg2[1000];$/;"	m	struct:__anon1	file:
msg2	testptelibrary.c	/^const char *msg2 = "goodbye ,world!\\n";$/;"	v
num	num.c	/^num(int f, const char *s)$/;"	f
num2fd	fd.c	/^num2fd(int fd)$/;"	f
open	file.c	/^open(const char *path, int mode)$/;"	f
opencons	console.c	/^opencons(void)$/;"	f
p_buf	pipe.c	/^	u_char p_buf[BY2PIPE];  \/\/ data buffer$/;"	m	struct:Pipe	file:
p_rpos	pipe.c	/^	u_int p_rpos;           \/\/ read position$/;"	m	struct:Pipe	file:
p_wpos	pipe.c	/^	u_int p_wpos;           \/\/ write position$/;"	m	struct:Pipe	file:
pageref	pageref.c	/^pageref(void *v)$/;"	f
pages	entry.S	/^pages:$/;"	l
pgfault	fork.c	/^pgfault(u_int va)$/;"	f	file:
pipe	pipe.c	/^pipe(int pfd[2])$/;"	f
pipeclose	pipe.c	/^pipeclose(struct Fd *fd)$/;"	f	file:
pipeisclosed	pipe.c	/^pipeisclosed(int fdnum)$/;"	f
piperead	pipe.c	/^piperead(struct Fd *fd, void *vbuf, u_int n, u_int offset)$/;"	f	file:
pipestat	pipe.c	/^pipestat(struct Fd *fd, struct Stat *stat)$/;"	f	file:
pipewrite	pipe.c	/^pipewrite(struct Fd *fd, const void *vbuf, u_int n, u_int offset)$/;"	f	file:
read	fd.c	/^read(int fdnum, void *buf, u_int n)$/;"	f
read_map	file.c	/^read_map(int fdnum, u_int offset, void **blk)$/;"	f
readline	sh.c	/^readline(char *buf, u_int n)$/;"	f
readn	fd.c	/^readn(int fdnum, void *buf, u_int n)$/;"	f
remove	file.c	/^remove(const char *path)$/;"	f
runcmd	sh.c	/^runcmd(char *s)$/;"	f
seek	fd.c	/^seek(int fdnum, u_int offset)$/;"	f
set_pgfault_handler	pgfault.c	/^set_pgfault_handler(void (*fn)(u_int va))$/;"	f
sfork	fork.c	/^sfork(void)$/;"	f
spawn	spawn.c	/^int spawn(char *prog, char **argv)$/;"	f
spawnl	spawn.c	/^spawnl(char *prog, char *args, ...)$/;"	f
st_dev	fd.h	/^	struct Dev *st_dev;$/;"	m	struct:Stat	typeref:struct:Stat::Dev
st_isdir	fd.h	/^	u_int st_isdir;$/;"	m	struct:Stat
st_name	fd.h	/^	char st_name[MAXNAMELEN];$/;"	m	struct:Stat
st_size	fd.h	/^	u_int st_size;$/;"	m	struct:Stat
stat	fd.c	/^stat(const char *path, struct Stat *stat)$/;"	f
strchr	string.c	/^strchr(const char *s, char c)$/;"	f
strcmp	string.c	/^strcmp(const char *p, const char *q)$/;"	f
strcpy	string.c	/^strcpy(char *dst, const char *src)$/;"	f
strlen	string.c	/^strlen(const char *s)$/;"	f
sum	init.c	/^sum(char *s, int n)$/;"	f
sync	file.c	/^sync(void)$/;"	f
syscall_cgetc	syscall_lib.c	/^syscall_cgetc()$/;"	f
syscall_env_alloc	lib.h	/^inline static int syscall_env_alloc(void)$/;"	f
syscall_env_destroy	syscall_lib.c	/^syscall_env_destroy(u_int envid)$/;"	f
syscall_getenvid	syscall_lib.c	/^syscall_getenvid(void)$/;"	f
syscall_ipc_can_send	syscall_lib.c	/^syscall_ipc_can_send(u_int envid, u_int value, u_int srcva, u_int perm)$/;"	f
syscall_ipc_recv	syscall_lib.c	/^syscall_ipc_recv(u_int dstva)$/;"	f
syscall_mem_alloc	syscall_lib.c	/^syscall_mem_alloc(u_int envid, u_int va, u_int perm)$/;"	f
syscall_mem_map	syscall_lib.c	/^syscall_mem_map(u_int srcid, u_int srcva, u_int dstid, u_int dstva, u_int perm)$/;"	f
syscall_mem_unmap	syscall_lib.c	/^syscall_mem_unmap(u_int envid, u_int va)$/;"	f
syscall_panic	syscall_lib.c	/^syscall_panic(char *msg)$/;"	f
syscall_putchar	syscall_lib.c	/^void syscall_putchar(char ch)$/;"	f
syscall_read_dev	syscall_lib.c	/^int syscall_read_dev(u_int va,u_int dev,u_int offset)$/;"	f
syscall_set_env_status	syscall_lib.c	/^syscall_set_env_status(u_int envid, u_int status)$/;"	f
syscall_set_pgfault_handler	syscall_lib.c	/^syscall_set_pgfault_handler(u_int envid, void (*func)(void), u_int xstacktop)$/;"	f
syscall_set_trapframe	syscall_lib.c	/^syscall_set_trapframe(u_int envid, struct Trapframe *tf)$/;"	f
syscall_write_dev	syscall_lib.c	/^int syscall_write_dev(u_int va,u_int dev,u_int offset)$/;"	f
syscall_yield	syscall_lib.c	/^syscall_yield(void)$/;"	f
umain	cat.c	/^umain(int argc, char **argv)$/;"	f
umain	echo.c	/^umain(int argc, char **argv)$/;"	f
umain	fktest.c	/^void umain()$/;"	f
umain	fstest.c	/^void umain()$/;"	f
umain	icode.c	/^umain(void)$/;"	f
umain	idle.c	/^umain()$/;"	f
umain	init.c	/^umain(int argc, char **argv)$/;"	f
umain	ls.c	/^umain(int argc, char **argv)$/;"	f
umain	num.c	/^umain(int argc, char **argv)$/;"	f
umain	pingpong.c	/^umain(void)$/;"	f
umain	sh.c	/^umain(int argc, char **argv)$/;"	f
umain	testarg.c	/^void umain(int argc, char **argv)$/;"	f
umain	testfdsharing.c	/^umain(int argc, char **argv)$/;"	f
umain	testpipe.c	/^umain(void)$/;"	f
umain	testpiperace.c	/^umain(void)$/;"	f
umain	testptelibrary.c	/^void umain (int argc, char **argv)$/;"	f
usage	ls.c	/^usage(void)$/;"	f
usage	sh.c	/^usage(void)$/;"	f
user_PrintChar	print.c	/^user_PrintChar(char * buf, char c, int length, int ladjust)$/;"	f
user_PrintNum	print.c	/^user_PrintNum(char * buf, unsigned long u, int base, int negFlag, $/;"	f
user_PrintString	print.c	/^user_PrintString(char * buf, char* s, int length, int ladjust)$/;"	f
user_assert	lib.h	130;"	d
user_bcopy	fork.c	/^void user_bcopy(const void *src, void *dst, size_t len)$/;"	f
user_bzero	fork.c	/^void user_bzero(void *v, u_int n)$/;"	f
user_lp_Print	print.c	/^user_lp_Print(void (*output)(void *, char *, int), $/;"	f
user_myoutput	printf.c	/^static void user_myoutput(void *arg, char *s, int l)$/;"	f	file:
user_out2string	fprintf.c	/^static void user_out2string(void *arg, char *s, int l)$/;"	f	file:
user_panic	lib.h	33;"	d
user_theFatalMsg	print.c	/^static const char user_theFatalMsg[] = "fatal error in user_lp_Print!";$/;"	v	file:
usr_is_elf_format	spawn.c	/^int usr_is_elf_format(u_char *binary){$/;"	f
usr_load_elf	spawn.c	/^usr_load_elf(int fd , Elf32_Phdr *ph, int child_envid){$/;"	f
vpd	entry.S	/^vpd:$/;"	l
vpt	entry.S	/^vpt:$/;"	l
wait	wait.c	/^wait(u_int envid)$/;"	f
write	fd.c	/^write(int fdnum, const void *buf, u_int n)$/;"	f
writef	printf.c	/^void writef(char *fmt, ...)$/;"	f
